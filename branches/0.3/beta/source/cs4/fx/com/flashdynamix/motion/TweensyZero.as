/**.______                                                   ________                              __         ___     /\__  _\                                                 /\_____  \                           /'__`\     /'___`\   \/_/\ \/ __  __  __     __     __    ___     ____  __  __\/____//'/'     __   _ __   ___     /\ \/\ \   /\_\ /\ \  ...\ \ \/\ \/\ \/\ \  /'__`\ /'__`\/' _ `\  /',__\/\ \/\ \    //'/'    /'__`\/\`'__\/ __`\   \ \ \ \ \  \/_/// /__ ....\ \ \ \ \_/ \_/ \/\  __//\  __//\ \/\ \/\__, `\ \ \_\ \  //'/'___ /\  __/\ \ \//\ \L\ \   \ \ \_\ \__  // /_\ \.....\ \_\ \___x___/'\ \____\ \____\ \_\ \_\/\____/\/`____ \ /\_______\ \____\\ \_\\ \____/    \ \____/\_\/\______/......\/_/\/__//__/   \/____/\/____/\/_/\/_/\/___/  `/___/> \\/_______/\/____/ \/_/ \/___/      \/___/\/_/\/_____/ ......................................................./\___/                                                      .......................................................\/__/....... Same great tween taste with 0 calories! .............................................................. */package com.flashdynamix.motion {	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.Event;	import flash.filters.BitmapFilter;	import flash.geom.ColorTransform;	import flash.geom.Matrix;	import flash.media.SoundChannel;	import flash.media.SoundTransform;	import flash.utils.Dictionary;	import flash.utils.getTimer;	
	/**	 * TweensyZero is a lightweight tweening engine designed specifically for developers who want to achieve small files sizes	 * but are not too fused about overall performance. Though TweensyZero is still quite effecient the original Tweensy class delivers the best tweening performance.<BR><BR>	 * The TweensyZero Class contains a collection of tweens specified by property tweens for an Object instance. The TweensyZero code library weighs about 2.9KB once compiled<BR>	 * <BR><BR>	 * A tween can be executed in one of the following manners:	 * <ul>	 * <li>to - allows for defining where the animation is going 'to' from its current position<BR>	 * e.g. <code>Tweensy.to(item, {x:50, y:100});</code>	 * </li>	 * <li>from - allows for defining where the animation is coming 'from' and will be going to its current position<BR>	 * e.g. <code>Tweensy.from(item, {x:200, y:150});</code>	 * </li>	 * <li>fromTo - allows for defining where the animation is coming 'from' and going 'to'<BR>	 * e.g. <code>Tweensy.fromTo(item, {x:200, y:150}, {x:50, y:100});</code>	 * </li>	 * </ul>	 */	public class TweensyZero {
		public static const version : Number = 0.2;		/**		 * Sets the refreshType to use the current frames per second of the SWF allowing for time based animations.		 * 		 * @see com.flashdynamix.motion.TweensyZero#refreshType		 */		public static const TIME : String = "time";		/**		 * Sets the refreshType to use the current seconds per frame on each ENTER_FRAME allowing for frame based animations.		 * 		 * @see com.flashdynamix.motion.TweensyZero#refreshType		 */		public static const FRAME : String = "frame";		/**		 * The default tween which will be used when none is provided using a to, from and fromTo method.		 * 		 * @see com.flashdynamix.motion.TweensyTimelineZero#ease TweensyTimelineZero.ease		 */		public static var defaultTween : Function = easeOut;		/**		 * Executed on each frame update.		 * 		 * @see com.flashdynamix.motion.TweensyZero#onUpdateParams		 */		public static var onUpdate : Function;		/**		 * Parameters applied to the onUpdate Function.		 * 		 * @see com.flashdynamix.motion.TweensyZero#onUpdate		 */		public static var onUpdateParams : Array;		/**		 * Executed when all tweens are complete.		 * 		 * @see com.flashdynamix.motion.TweensyZero#onComplete		 */		public static var onComplete : Function;		/**		 * Parameters applied to the onComplete Function.		 * 		 * @see com.flashdynamix.motion.TweensyZero#onCompleteParams		 */		public static var onCompleteParams : Array;		/**		 * Defines whether the TweensyGroup Class will automatically resolve property tween conflicts.<BR>		 * Property tween conflicts occur when one property tweens time overlaps another.		 */		public static var lazyMode : Boolean = true;		protected static var _secondsPerFrame : Number = 1 / 30;		protected static var frame : Sprite = new Sprite();		protected static var time : int = 0;		protected static var _refreshType : String = "time";		protected static var _paused : Boolean = false;		public static var filters : Dictionary = new Dictionary(true);		protected static var map : Dictionary = new Dictionary(true);		protected static var first : TweensyTimelineZero;		protected static var last : TweensyTimelineZero;		protected static var _timelines : int = 0;
		/**		 * Adds a to based tween using the properties defined in the target Object.		 * 		 * @param instance The instance Object to be tweened or multiple instances if using the type Array e.g. [item1, item2]		 * @param to An Object containing the properties you would like to tween to e.g. {x:50, y:25}		 * or this can be relative e.g. {x:'50', y:'-25'} or can be a random position e.g. {x:'-50, 50', y:'-25, 25'}		 * @param duration The time in secs you would like the tween to run.		 * @param ease The ease equation you would like to use e.g. Quintic.easeOut.		 * @param delayStart The delay you would like to use at the beginning of the tween and every subsequent REPLAY of a tween.		 * @param update This param is used when tweening a property in an Object which needs to be applied onto another Object each time		 * the tween occurs.<BR>		 * For example to(new DropShadowFilter(), {alpha:0}, myDisplayItem); Will apply the tweening DropShadowFilter onto the DisplayObject 'myDisplayItem'.		 * @param onComplete The onComplete event handler you would like to fire once the tween is complete.		 * @param onCompleteParams The params applied to the onComplete handler.		 * 		 * @return An instance to the TweensyTimelineZero which can used to manage this tween.		 * 		 * @see com.flashdynamix.motion.TweensyTimelineZero		 */		public static function to(instance : Object, to : Object, duration : Number = 0.5, ease : Function = null, delayStart : Number = 0, update : Object = null, onComplete : Function = null, onCompleteParams : Array = null) : TweensyTimelineZero {			if(!hasTimelines) startUpdate();						var timeline : TweensyTimelineZero = setup(instance, duration, ease, delayStart, onComplete, onCompleteParams, update);						for(var propName:String in to) {				timeline.to[propName] = translate(instance[propName], to[propName]);				timeline.properties++;			}						add(timeline);						return timeline;		}
		/**		 * Adds a from based tween using the properties defined in the from Object.		 * 		 * @param instance The instance Object to be tweened or multiple instances if using the type Array e.g. [item1, item2]		 * @param from An Object containing the properties you would like to tween from e.g. {x:50, y:25}		 * or this can be relative e.g. {x:'50', y:'-25'} or can be a random position e.g. {x:'-50, 50', y:'-25, 25'}		 * @param duration The time in secs you would like the tween to run.		 * @param ease The ease equation you would like to use e.g. Quintic.easeOut.		 * @param delayStart The delay you would like to use at the beginning of the tween and every subsequent REPLAY of a tween.		 * @param update This param is used when tweening a property in a Object which needs to be applied onto another Object each time		 * the tween occurs.<BR>		 * For example to(new DropShadowFilter(), {alpha:0}, myDisplayItem); Will apply the tweening DropShadowFilter onto the DisplayObject 'myDisplayItem'.		 * @param onComplete The onComplete event handler you would like to fire once the tween is complete.		 * @param onCompleteParams The params applied to the onComplete handler.		 * 		 * @return An instance to the TweensyTimelineZero which can used to manage this tween.		 * 		 * @see com.flashdynamix.motion.TweensyTimelineZero		 */		public static function from(instance : Object, from : Object, duration : Number = 0.5, ease : Function = null, delayStart : Number = 0, update : Object = null, onComplete : Function = null, onCompleteParams : Array = null) : TweensyTimelineZero {			if(!hasTimelines) startUpdate();						var timeline : TweensyTimelineZero = setup(instance, duration, ease, delayStart, onComplete, onCompleteParams, update);						for(var propName:String in from) {				timeline.to[propName] = instance[propName];				instance[propName] = translate(instance[propName], from[propName]);				timeline.properties++;			}						add(timeline);						return timeline;		}
		/**		 * Adds a from to based tween using the properties defined in the from and to Objects.		 * 		 * @param instance The instance Object to be tweened or multiple instances if using the type Array e.g. [item1, item2]		 * @param from An Object containing the properties you would like to tween from e.g. {x:50, y:25}		 * or this can be relative e.g. {x:'50', y:'-25'} or can be a random position e.g. {x:'-50, 50', y:'-25, 25'}		 * @param to An Object containing the properties you would like to tween to e.g. {x:50, y:25}		 * or this can be relative e.g. {x:'50', y:'-25'} or can be a random position e.g. {x:'-50, 50', y:'-25, 25'}		 * @param duration The time in secs you would like the tween to run		 * @param ease The ease equation you would like to use e.g. Quintic.easeOut		 * @param delayStart The delay you would like to use at the beginning of the tween and every subsequent REPLAY of a tween		 * @param update This param is used when tweening a property in a Object which needs to be applied onto another Object each time		 * the tween occurs.<BR>		 * For example to(new DropShadowFilter(), {alpha:0}, myDisplayItem); Will apply the tweening DropShadowFilter onto the DisplayObject 'myDisplayItem'		 * @param onComplete The onComplete event handler you would like to fire once the tween is complete.		 * @param onCompleteParams The params applied to the onComplete handler.		 * 		 * @return An instance to the TweensyTimelineZero which can used to manage this tween.		 * 		 * @see com.flashdynamix.motion.TweensyTimelineZero		 */		public static function fromTo(instance : Object, from : Object, to : Object, duration : Number = 0.5, ease : Function = null, delayStart : Number = 0, update : Object = null, onComplete : Function = null, onCompleteParams : Array = null) : TweensyTimelineZero {			if(!hasTimelines) startUpdate();						var timeline : TweensyTimelineZero = setup(instance, duration, ease, delayStart, onComplete, onCompleteParams, update);						for(var propName:String in to) {				timeline.to[propName] = translate(instance[propName], to[propName]);				instance[propName] = translate(instance[propName], from[propName]);				timeline.properties++;			}						add(timeline);						return timeline;		}
		private static function add(item : TweensyTimelineZero) : void {						addInstance(item);						if(first) {				first.previous = item;			} else {				last = item;			}						item.next = first;			first = item;						_timelines++;		}		private static function removeOverlap(item : TweensyTimelineZero) : void {			var timelineList : Array = map[item.instance];			var timeline : TweensyTimelineZero;			var totalDuration : Number;						for each(timeline in timelineList) {								totalDuration = timeline.delayStart + timeline.duration + timeline.delayEnd;								if(timeline.instance == item.instance && item.delayStart < (totalDuration - timeline.time)) {										for(var propName:String in item.to) {						delete timeline.to[propName];						timeline.properties--;					}										if(timeline.properties == 0) remove(timeline);				}			}		}		private static function remove(item : TweensyTimelineZero) : void {			if(item.previous) item.previous.next = item.next;			if(item.next) item.next.previous = item.previous;						if(item == first) {				first = first.next;				if(first) first.previous = null;			}						if(item == last) {				last = item.previous;				if(last) last.next = null;			}						removeInstance(item);						_timelines--;						if(_timelines == 0) stopUpdate();		}		private static function addInstance(item : TweensyTimelineZero) : void {			if(lazyMode) removeOverlap(item);						var timelineList : Array = map[item.instance];			if(!timelineList) map[item.instance] = timelineList = [];			timelineList[timelineList.length] = item;		}		private static function removeInstance(item : TweensyTimelineZero) : void {			var timelinesList : Array = map[item.instance];							if(timelinesList) {				var index : int = timelinesList.indexOf(item);				if(index != -1) {					if(timelinesList.length <= 1) {						map[item.instance].length = 0;					} else {						timelinesList.splice(index, 1);					}				}			}		}
		private static function setup(instance : Object, duration : Number, ease : Function, delayStart : Number, onComplete : Function, onCompleteParams : Array, update : Object) : TweensyTimelineZero {						var timeline : TweensyTimelineZero = new TweensyTimelineZero();			timeline.instance = instance;			timeline.duration = duration;			timeline.ease = (ease != null) ? ease : defaultTween;			timeline.delayStart = delayStart;			timeline.update = update;			timeline.onComplete = onComplete;			timeline.onCompleteParams = onCompleteParams;						if(instance is BitmapFilter && update != null) {				var filterList : Array = filters[update];							if(filterList == null || filterList.length != DisplayObject(update).filters.length) {					filterList = filters[update] = DisplayObject(update).filters;				}							if(filterList.indexOf(instance) == -1) filterList.push(instance);								DisplayObject(update).filters = filterList;			}						return timeline;		}
		/**		 * Allows for removing tweens which have been executed by the TweensyZero Class. <BR>		 * Tweens can be stopped via an instance or tween props by the following methods :		 * <ul>		 * <li>stop(instance); - stops all property tweens for this instance.</li>		 * <li>stop(instance, "x", "y"); - stops all x,y property tweens for this instance.</li>		 * <li>stop([instance1, instance2]); - stops all property tweens for these instances.</li>		 * <li>stop([instance1, instance2], "x", "y"); - stops all x,y property tweens for these instances.</li>		 * <li>stop(null, "x", "y"); - stops all x,y property tweens.</li>		 * <li>stop(); - stops all tweens, although it is recommeded to use the stopAll method as this is more efficient.</li>		 * </ul>		 * 		 */		public static function stop(instance : * = null, ...props : Array) : void {			var items : Array = (instance is Array) ? instance : (instance == null) ? null : [instance];			var timeline : TweensyTimelineZero;						for(var i : int = items.length - 1;i >= 0; i--) {								var timelineList : Array = map[items[i]];								for each(timeline in timelineList) {										if(items == null || items.indexOf(timeline.instance) != -1) {												if(props.length == 0) {							remove(timeline);						} else {													for each(var propName:String in props) {								if(timeline.to[propName]) {									delete timeline.to[propName];									timeline.properties--;								}							}													if(timeline.properties == 0) remove(timeline);						}					}				}			}		}
		/**		 * Stops all tweens which have been executed by the TweensyZero Class.		 */		public static function stopAll() : void {			_timelines = 0;			first = null;			last = null;			map = new Dictionary(true);						stopUpdate();		}
		/**		 * Pauses all tweens which have been executed by the TweensyZero Class.		 */		public static function pause() : void {			if(_paused) return;						_paused = true;						stopUpdate();		}
		/**		 * Resumes all tweens which have been executed by the TweensyZero Class.		 */		public static function resume() : void {			if(!_paused) return;						_paused = false;						startUpdate();		}
		/**		 * Whether the TweensyZero Class is currently paused.		 */		public static function get paused() : Boolean {			return _paused;		}
		public static function set secondsPerFrame(spf : Number) : void {			_secondsPerFrame = spf;		}
		/**		 * Sets how many seconds per frame are added to to each on an ENTER_FRAME when TweensyZero Class's refreshType is of the TweensyZero.FRAME mode.<BR>		 * This property and feature is intended as an alternative to the TweensyZero.TIME (time based animation) mode which can result in jumpy effects.		 * Instead TweensyZero.FRAME ensures that every frame is rendered in the duration of your animation.		 * e.g. If your FLA frame rate is 30 frames per second then set secondsPerFrame to 1 second for every 30 frames (1/30).		 * 		 * @see com.flashdynamix.motion.TweensyZero#refreshType		 * @see com.flashdynamix.motion.TweensyZero#FRAME 		 */		public static function get secondsPerFrame() : Number {			return _secondsPerFrame;		}
		public static function set refreshType(type : String) : void {			_refreshType = type;		}
		/**		 * Sets the timing system currently in use by the TweensyZero Class.<BR>		 * @param type Can be either :		 * <ul>		 * <li>TweensyZero.TIME</li>		 * <li>TweensyZero.FRAME</li>		 * </ul>		 * @see com.flashdynamix.motion.TweensyZero#FRAME 	 		 * @see com.flashdynamix.motion.TweensyZero#TIME		 * @see com.flashdynamix.motion.TweensyZero#secondsPerFrame		 */		public static function get refreshType() : String {			return _refreshType;		}
		/**		 * Total number of animations in progress for the TweensyZero class.		 */		public static function get timelines() : int {			return _timelines;		}
		/**		 * Whether the TweensyZero Class has any timeline animations.		 */		public static function get hasTimelines() : Boolean {			return (timelines > 0);		}
		private static function update(event : Event) : void {			var dif : Number = _secondsPerFrame;						if(refreshType == TIME) {				dif = getTimer() - time;				time += dif;				dif *= 0.001;			}						var timeline : TweensyTimelineZero = first;			var next : TweensyTimelineZero;			var args : Array;						while(timeline) {								next = timeline.next;				timeline.time += dif;								if(timeline.time > timeline.delayStart) {										var currentTime : Number = timeline.time - timeline.delayStart;					currentTime = (currentTime > timeline.duration) ? timeline.duration : currentTime;					var finished : Boolean = (currentTime >= timeline.duration + timeline.delayEnd);										args = [currentTime, 0, 1, timeline.duration].concat(timeline.easeParams);										var position : Number = timeline.ease.apply(null, args);										var propName : String;										if(!timeline.inited) {						for(propName in timeline.to) {							timeline.from[propName] = timeline.instance[propName];							timeline.change[propName] = timeline.to[propName] - timeline.from[propName];						}						timeline.inited = true;					}										for(propName in timeline.to) {						timeline.instance[propName] = timeline.from[propName] + timeline.change[propName] * position;					}										if(timeline.update != null) {						//						if(timeline.instance is ColorTransform) {							DisplayObject(timeline.update).transform.colorTransform = timeline.instance;						} else if (timeline.instance is Matrix) {							DisplayObject(timeline.update).transform.matrix = timeline.instance;						} else if (timeline.instance is SoundTransform) {
							if(timeline.update is SoundChannel) {								SoundChannel(timeline.update).soundTransform = timeline.instance;
							} else {								Sprite(timeline.update).soundTransform = timeline.instance;							}						} else if (timeline.instance is BitmapFilter) {							DisplayObject(timeline.update).filters = filters[timeline.update];						}						//					}										if(timeline.onUpdate != null) timeline.onUpdate.apply(null, timeline.onUpdateParams);										if(finished) {						remove(timeline);						if(timeline.onComplete != null) timeline.onComplete.apply(null, timeline.onCompleteParams);					}				}								timeline = next;			}						if(onUpdate != null) onUpdate.apply(null, onUpdateParams);						if(!hasTimelines) {				stopUpdate();				if(onComplete != null) onComplete.apply(null, onCompleteParams);			}		}
		private static function easeOut(t : Number, b : Number, c : Number, d : Number) : Number {			return c * ((t = t / d - 1) * t * t * t * t + 1) + b;		}
		private static function startUpdate() : void {			time = getTimer();						frame.addEventListener(Event.ENTER_FRAME, update, false, 0, true);		}
		private static function stopUpdate() : void {			first = null;			last = null;			frame.removeEventListener(Event.ENTER_FRAME, update);		}
		private static function translate(current : Number, value : *) : Number {						var target : Number;						if(value is String) {				var values : Array = String(value).split(",");				if(values.length == 1) {					target = current + parseFloat(value);				} else {					var start : Number = parseFloat(values[0]), end : Number = parseFloat(values[1]);					target = current + start + (Math.random() * (end - start));				}			} else {				target = value;			}						return target;		}
		public function toString() : String {			return "TweensyZero " + version + " {timelines:" + timelines + "}";		}	}}