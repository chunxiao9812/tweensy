package com.flashdynamix.motion.plugins {	import flash.display.DisplayObject;	import flash.geom.Rectangle;	import com.flashdynamix.motion.plugins.AbstractTween;		/**	 * @author FlashDynamix	 */	public class RectangleTween extends AbstractTween {		private var _current : Rectangle;		protected var _to : Rectangle;		protected var _from : Rectangle;		/** @private */		internal var displayObject : DisplayObject;		public function RectangleTween() {			_to = new Rectangle();			_from = new Rectangle();		}		override public function construct(...params : Array) : void {			super.construct();						_current = params[0];			displayObject = params[1];						apply();		}		override protected function set to(item : Object) : void {			_to = item as Rectangle;		}		override protected function get to() : Object {			return _to;		}		override protected function set from(item : Object) : void {			_from = item as Rectangle;		}		override protected function get from() : Object {			return _from;		}		override public function get current() : Object {			return _current;		}		override public function get instance() : Object {			return (displayObject) ? displayObject : current;		}		override public function removeOverlap(item : AbstractTween) : void {			if(item is RectangleTween && (current == item.current || (RectangleTween(item).displayObject != null && displayObject == RectangleTween(item).displayObject)) ) {				for(var propName:String in item.propNames) remove(propName);			}		}		override public function toTarget(to : Object) : void {			if(to is Rectangle) {				var rect : Rectangle = to as Rectangle;							add("x", rect.x, false);				add("y", rect.y, false);				add("width", rect.width, false);				add("height", rect.height, false);			} else {				super.toTarget(to);			}		}		override public function fromTarget(from : Object) : void {			if(from is Rectangle) {				var rect : Rectangle = from as Rectangle;							add("x", rect.x, true);				add("y", rect.y, true);				add("width", rect.width, true);				add("height", rect.height, true);			} else {				super.fromTarget(from);			}		}		override public function update(position : Number) : void {			var q : Number = 1 - position;			var propName : String;						if(!inited && _propCount > 0) {				if(displayObject) {					_current = displayObject.scrollRect;					_from = displayObject.scrollRect;				} else {					for(propName in propNames) _from[propName] = _current[propName];				}				inited = true;			}						for(propName in propNames) {								if(propName == "x") {					_current.x = _from.x * q + _to.x * position;				} else if(propName == "y") {					_current.y = _from.y * q + _to.y * position;				} else if(propName == "width") {					_current.width = _from.width * q + _to.width * position;				} else if(propName == "height") {					_current.height = _from.height * q + _to.height * position;				} else {					_current[propName] = _from[propName] * q + _to[propName] * position;				}								if(timeline.snapToClosest) _current[propName] = Math.round(_current[propName]);			}						apply();		}		override public function apply() : void {			if(displayObject == null) return;						displayObject.scrollRect = _current;		}		override public function dispose() : void {			_to = null;			_from = null;			_current = null;			displayObject = null;						super.dispose();		}	}}